#!/usr/bin/python

# Copyright (C) 2011 Javier Palacios
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License Version 2
# as published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.


from BaseHTTPServer import BaseHTTPRequestHandler , HTTPServer

from repocache.cache import get_file

try :
    from mod_python import apache
except :
    import repocache.apcompat as apache

import os
import repolib


class ServerConf ( dict ) :

    def __init__ ( self ) :
        dict.__init__ ( self )

    def append ( self , key , ( reporoot , url ) , mirror_class=None ) :
        if mirror_class and key in self.keys() :
            print "WARNING: Repo %s : %s object from %s trying to overwrite existing entry at %s" % ( key , mirror_class , reporoot , self[key] )
            return
        if url and not url.endswith('/') :
            print "WARNING : Repo %s : Fix configuration, url should have a trailing '/'" % key
            url += "/"
        self[key] = reporoot , url

    def __getitem__ ( self , key ) :
        return dict.__getitem__( self , key )[0]

    def source_url ( self , key ) :
        return dict.__getitem__( self , key )[1]


server_conf = ServerConf()

for reponame in repolib.config.get_all_build_repos() :
    try :
        repo = repolib.BuildRepository.new( reponame )
        server_conf.append( reponame , ( repo.repo_path() , None ) )
    except Exception , ex :
        print "Repo %s : %s" % ( reponame , ex )

for repoconf in repolib.config.get_all_mirror_configs( "class" , "passthru" ) :
    try :
        repo = repolib.MirrorRepository.new( repoconf.name )
        server_conf.append( reponame , ( repo.repo_path() , None ) , "passthru" )
    except Exception , ex :
        print "Repo %s : %s" % ( reponame , ex )

for repoconf in repolib.config.get_all_mirror_configs( "class" , "cache" ) :
    try :
        repo = repolib.MirrorRepository.new( repoconf.name )
        server_conf.append( reponame , ( repo.repo_path() , repo.base_url() ) , "cache" )
    except Exception , ex :
        print "Repo %s : %s" % ( repoconf.name , ex )


class Handler ( BaseHTTPRequestHandler ) :

    status = None
    content_type = None

    def sendfile ( self , path ) :
        fd = open( path )
        self.wfile.write( fd.read() )
        fd.close()

    def write ( self , msg ) :
        self.wfile.write( msg )

    def log_error ( self , msg , severity=apache.APLOG_ERROR ) :
        BaseHTTPRequestHandler.log_error( self , "%s : %s" % ( severity , msg ) )

    def do_GET ( self ) :

        repo , uri = os.path.normpath(self.path).strip('/').split('/',1)

        if not server_conf.has_key( repo ) :
            self.status = 404
            self.log_error( "Unknown repo '%s'" % repo )

        else :

            local_path = os.path.join( server_conf[repo] , uri )

            source_url = server_conf.source_url( repo )
            if source_url :

                remote_url = repolib.utils.urljoin( source_url , uri )
                retcode = get_file( self , local_path , remote_url )

                if retcode :
                    if self.status and self.status != retcode :
                        self.log_error( "Return code '%s' didn't match status '%s'" % ( retcode , self.status ) )
                    self.status = retcode

            else :
                if os.path.isfile( local_path ) :
                    self.status = 200
                    self.sendfile( local_path )
                else :
                    self.status = 404
                    self.log_error( "%s not found" % self.path )

        self.send_response( self.status )

        if self.content_type :
            self.send_header( "Content-Type" , self.content_type )

        self.end_headers()


try :
    server = HTTPServer( ('',8080) , Handler )
    server.serve_forever()
except KeyboardInterrupt , ex :
    server.socket.close()

